"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  extractIdentifiers: () => extractIdentifiers,
  isNewScope: () => isNewScope,
  walk: () => walk2,
  walkAST: () => walkAST,
  walkFunctionParams: () => walkFunctionParams
});
module.exports = __toCommonJS(src_exports);
var import_parser = require("@babel/parser");

// node_modules/.pnpm/estree-walker@3.0.1/node_modules/estree-walker/src/walker.js
var WalkerBase = class {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
  }
  replace(parent, prop, index, node) {
    if (parent) {
      if (index !== null) {
        parent[prop][index] = node;
      } else {
        parent[prop] = node;
      }
    }
  }
  remove(parent, prop, index) {
    if (parent) {
      if (index !== null) {
        parent[prop].splice(index, 1);
      } else {
        delete parent[prop];
      }
    }
  }
};

// node_modules/.pnpm/estree-walker@3.0.1/node_modules/estree-walker/src/sync.js
var SyncWalker = class extends WalkerBase {
  constructor(enter, leave) {
    super();
    this.enter = enter;
    this.leave = leave;
  }
  visit(node, parent, prop, index) {
    if (node) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node;
        if (removed)
          return null;
      }
      for (const key in node) {
        const value = node[key];
        if (typeof value !== "object") {
          continue;
        } else if (Array.isArray(value)) {
          for (let i = 0; i < value.length; i += 1) {
            if (value[i] !== null && typeof value[i].type === "string") {
              if (!this.visit(value[i], node, key, i)) {
                i--;
              }
            }
          }
        } else if (value !== null && typeof value.type === "string") {
          this.visit(value, node, key, null);
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node;
  }
};

// node_modules/.pnpm/estree-walker@3.0.1/node_modules/estree-walker/src/index.js
function walk(ast, { enter, leave }) {
  const instance = new SyncWalker(enter, leave);
  return instance.visit(ast, null);
}

// src/index.ts
var import_types2 = require("@babel/types");

// src/utils/babel.ts
var import_types = require("@babel/types");
var NEW_SCOPE = [
  "CatchClause",
  "ForInStatement",
  "ForOfStatement"
];
var isNewScope = (node) => NEW_SCOPE.includes(node.type) || (0, import_types.isFunction)(node);
function walkFunctionParams(node, onIdent) {
  for (const p of node.params) {
    for (const id of extractIdentifiers(p)) {
      onIdent(id);
    }
  }
}
function extractIdentifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression": {
      let object = param;
      while (object.type === "MemberExpression") {
        object = object.object;
      }
      nodes.push(object);
      break;
    }
    case "ObjectPattern":
      for (const prop of param.properties) {
        if (prop.type === "RestElement") {
          extractIdentifiers(prop.argument, nodes);
        } else {
          extractIdentifiers(prop.value, nodes);
        }
      }
      break;
    case "ArrayPattern":
      param.elements.forEach((element) => {
        if (element)
          extractIdentifiers(element, nodes);
      });
      break;
    case "RestElement":
      extractIdentifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extractIdentifiers(param.left, nodes);
      break;
  }
  return nodes;
}

// src/index.ts
var walk2 = (code, walkHooks, { filename, parserPlugins } = {}) => {
  const plugins = parserPlugins || [];
  if (filename) {
    if (/\.tsx?$/.test(filename))
      plugins.push("typescript");
    if (filename.endsWith("x"))
      plugins.push("jsx");
  }
  const ast = (0, import_parser.parse)(code, {
    sourceType: "module",
    plugins
  });
  walkAST(ast.program, walkHooks);
  return ast;
};
var walkAST = (ast, { enter, leave }) => {
  let currentScope = {};
  const scopeStack = [currentScope];
  walk(ast, {
    enter(node, parent, ...args) {
      enterNode(node, parent);
      enter == null ? void 0 : enter.call(getHookContext(this, [parent, ...args]), node);
    },
    leave(node, parent, ...args) {
      leaveNode(node, parent);
      leave == null ? void 0 : leave.call(getHookContext(this, [parent, ...args]), node);
    }
  });
  function getHookContext(ctx, [parent, key, index]) {
    const scope = scopeStack.reduce((prev, curr) => ({ ...prev, ...curr }), {});
    return {
      ...ctx,
      parent,
      key,
      index,
      scope,
      scopes: scopeStack,
      level: scopeStack.length
    };
  }
  function enterNode(node, parent) {
    if (isNewScope(node) || node.type === "BlockStatement" && !isNewScope(parent))
      scopeStack.push(currentScope = {});
    if ((0, import_types2.isFunction)(node)) {
      walkFunctionParams(node, registerBinding);
    } else if (node.type === "CatchClause" && node.param && node.param.type === "Identifier")
      registerBinding(node.param);
    if (node.type === "BlockStatement" || node.type === "Program") {
      for (const stmt of node.body) {
        if (stmt.type === "VariableDeclaration" && stmt.kind === "var") {
          walkVariableDeclaration(stmt);
        } else if (stmt.type === "FunctionDeclaration" && stmt.id) {
          registerBinding(stmt.id);
        }
      }
    }
  }
  function leaveNode(node, _parent) {
    if (node.type === "BlockStatement") {
      scopeStack.pop();
      currentScope = scopeStack[scopeStack.length - 1];
    } else if (node.type === "FunctionDeclaration" || node.type === "ClassDeclaration") {
      if (node.declare || !node.id)
        return;
      registerBinding(node.id);
    } else if (node.type === "VariableDeclaration") {
      walkVariableDeclaration(node);
    } else if (node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "VariableDeclaration") {
      walkVariableDeclaration(node.declaration);
    }
  }
  function walkVariableDeclaration(stmt) {
    if (stmt.declare)
      return;
    for (const decl of stmt.declarations) {
      for (const id of extractIdentifiers(decl.id)) {
        registerBinding(id);
      }
    }
  }
  function registerBinding(id) {
    if (currentScope) {
      currentScope[id.name] = id;
    } else {
      error(
        "registerBinding called without active scope, something is wrong.",
        id
      );
    }
  }
  function error(msg, node) {
    const e = new Error(msg);
    e.node = node;
    throw e;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  extractIdentifiers,
  isNewScope,
  walk,
  walkAST,
  walkFunctionParams
});
